<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>So Sánh Thuật Toán Mã Hóa Thực Tế</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .font-mono {
            font-family: 'Fira-Code', monospace;
        }
        .algo-card {
            border: 1px solid #374151;
        }
        .data-block {
            display: inline-block;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 6px;
            font-size: 0.75rem;
            text-align: center;
            transition: all 0.3s ease;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .plaintext-block {
            background-color: #374151;
            color: #d1d5db;
            border: 1px solid #4b5563;
        }
        .encrypted-block {
            background-color: #059669;
            color: #ffffff;
            font-weight: 500;
            border: 1px solid #047857;
        }
        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }
        .performance-metric {
            background: linear-gradient(135deg, #1f2937 0%, #374151 100%);
            border: 1px solid #4b5563;
            transition: transform 0.2s ease;
        }
        .performance-metric:hover {
            transform: translateY(-2px);
        }
        .processing {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-cyan-400">Phân Tích Hiệu Năng Thuật Toán Mã Hóa Thực Tế</h1>
            <p class="text-gray-400 mt-2">Thực hiện mã hóa thực tế và đo lường các chỉ tiêu hiệu năng chi tiết.</p>
        </header>

        <!-- Algorithm Explanations Section -->
        <div class="mb-12">
            <h2 class="text-3xl font-bold text-center text-cyan-400 mb-8">Tìm Hiểu Về Các Thuật Toán</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                <div class="bg-gray-800 p-6 rounded-2xl border border-gray-700">
                    <h3 class="text-xl font-bold text-green-400 mb-2">AES-256</h3>
                    <p class="text-sm text-gray-300">Thuật toán mã hóa khối tiêu chuẩn hiện tại, sử dụng khóa 256-bit với 14 vòng mã hóa. Được sử dụng rộng rãi trong các ứng dụng bảo mật cao.</p>
                </div>
                <div class="bg-gray-800 p-6 rounded-2xl border border-gray-700">
                    <h3 class="text-xl font-bold text-red-400 mb-2">DES</h3>
                    <p class="text-sm text-gray-300">Thuật toán mã hóa khối cổ điển, sử dụng khóa 56-bit. Hiện không còn an toàn do khóa quá ngắn, dễ bị tấn công vét cạn.</p>
                </div>
                <div class="bg-gray-800 p-6 rounded-2xl border border-gray-700">
                    <h3 class="text-xl font-bold text-blue-400 mb-2">3DES</h3>
                    <p class="text-sm text-gray-300">Cải tiến của DES, thực hiện mã hóa 3 lần liên tiếp với khóa 168-bit. An toàn hơn DES nhưng chậm và đang bị thay thế bởi AES.</p>
                </div>
                <div class="bg-gray-800 p-6 rounded-2xl border border-gray-700">
                    <h3 class="text-xl font-bold text-purple-400 mb-2">RC4</h3>
                    <p class="text-sm text-gray-300">Thuật toán mã hóa dòng, từng được sử dụng trong SSL/WEP. Có nhiều lỗ hổng bảo mật nghiêm trọng và không được khuyến nghị sử dụng.</p>
                </div>
            </div>
        </div>

        <!-- Input Section -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg mb-8 sticky top-4 z-10 border border-gray-700">
            <div class="flex flex-col gap-4">
                <div class="flex flex-col md:flex-row gap-4">
                    <textarea id="plaintext" class="flex-1 p-3 bg-gray-900 border-2 border-gray-600 rounded-lg focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 transition font-mono" rows="3" placeholder="Nhập dữ liệu cần mã hóa (văn bản càng dài, phép đo càng chính xác)...">Hello World! This is a test message for encryption performance analysis. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</textarea>
                    <button id="encryptBtn" class="bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 px-6 rounded-lg transition transform hover:scale-105 shadow-md flex-shrink-0 disabled:opacity-50 disabled:cursor-wait">
                        Thực Hiện Mã Hóa
                    </button>
                </div>
                <div class="text-sm text-gray-400">
                    <span id="inputStats">Độ dài: 0 ký tự, 0 bytes</span>
                </div>
            </div>
        </div>

        <!-- Visualization Section -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-12">
            <div class="algo-card bg-gray-800 rounded-2xl p-6">
                <h2 class="text-2xl font-bold text-green-400 mb-4">AES-256</h2>
                <div class="text-sm text-gray-400 space-y-1 mb-4 border-b border-gray-700 pb-4">
                    <div><strong>Loại:</strong> Mã hóa khối</div>
                    <div><strong>Kích thước khối:</strong> 128 bit (16 bytes)</div>
                    <div><strong>Độ dài khóa:</strong> 256 bit</div>
                </div>
                <h3 class="font-semibold mb-2">Kết quả mã hóa:</h3>
                <div id="aes-result" class="bg-black bg-opacity-40 p-3 rounded-md min-h-[60px] font-mono text-xs break-all"></div>
            </div>

            <div class="algo-card bg-gray-800 rounded-2xl p-6">
                <h2 class="text-2xl font-bold text-red-400 mb-4">DES</h2>
                <div class="text-sm text-gray-400 space-y-1 mb-4 border-b border-gray-700 pb-4">
                    <div><strong>Loại:</strong> Mã hóa khối</div>
                    <div><strong>Kích thước khối:</strong> 64 bit (8 bytes)</div>
                    <div><strong>Độ dài khóa:</strong> 56 bit</div>
                </div>
                <h3 class="font-semibold mb-2">Kết quả mã hóa:</h3>
                <div id="des-result" class="bg-black bg-opacity-40 p-3 rounded-md min-h-[60px] font-mono text-xs break-all"></div>
            </div>

            <div class="algo-card bg-gray-800 rounded-2xl p-6">
                <h2 class="text-2xl font-bold text-blue-400 mb-4">3DES</h2>
                <div class="text-sm text-gray-400 space-y-1 mb-4 border-b border-gray-700 pb-4">
                    <div><strong>Loại:</strong> Mã hóa khối</div>
                    <div><strong>Kích thước khối:</strong> 64 bit (8 bytes)</div>
                    <div><strong>Độ dài khóa:</strong> 168 bit</div>
                </div>
                <h3 class="font-semibold mb-2">Kết quả mã hóa:</h3>
                <div id="tripledes-result" class="bg-black bg-opacity-40 p-3 rounded-md min-h-[60px] font-mono text-xs break-all"></div>
            </div>

            <div class="algo-card bg-gray-800 rounded-2xl p-6">
                <h2 class="text-2xl font-bold text-purple-400 mb-4">RC4</h2>
                <div class="text-sm text-gray-400 space-y-1 mb-4 border-b border-gray-700 pb-4">
                    <div><strong>Loại:</strong> Mã hóa dòng</div>
                    <div><strong>Kích thước khối:</strong> N/A (Stream)</div>
                    <div><strong>Độ dài khóa:</strong> 128 bit</div>
                </div>
                <h3 class="font-semibold mb-2">Kết quả mã hóa:</h3>
                <div id="rc4-result" class="bg-black bg-opacity-40 p-3 rounded-md min-h-[60px] font-mono text-xs break-all"></div>
            </div>
        </div>

        <!-- Performance Metrics Dashboard -->
        <div class="mb-12" id="performance-section" style="display: none;">
            <h2 class="text-3xl font-bold text-center text-cyan-400 mb-8">Bảng Điều Khiển Hiệu Năng</h2>
            
            <!-- Real-time Performance Metrics -->
            <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4 mb-8" id="metrics-grid">
                <!-- Metrics will be dynamically populated -->
            </div>

            <!-- Performance Charts -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div class="bg-gray-800 p-6 rounded-2xl">
                    <h3 class="text-xl font-bold mb-4 text-white">Tốc Độ Mã Hóa (MB/s)</h3>
                    <div class="chart-container"><canvas id="speedChart"></canvas></div>
                </div>

                <div class="bg-gray-800 p-6 rounded-2xl">
                    <h3 class="text-xl font-bold mb-4 text-white">Thời Gian Xử Lý (ms)</h3>
                    <div class="chart-container"><canvas id="timeChart"></canvas></div>
                </div>

                <div class="bg-gray-800 p-6 rounded-2xl">
                    <h3 class="text-xl font-bold mb-4 text-white">Thông Lượng So Sánh</h3>
                    <div class="chart-container"><canvas id="throughputChart"></canvas></div>
                </div>

                <div class="bg-gray-800 p-6 rounded-2xl">
                    <h3 class="text-xl font-bold mb-4 text-white">Hiệu Suất CPU & Memory</h3>
                    <div class="chart-container"><canvas id="resourceChart"></canvas></div>
                </div>
            </div>
        </div>

        <!-- Detailed Results Table -->
        <div class="bg-gray-800 p-6 rounded-2xl shadow-lg border border-gray-700" id="results-table" style="display: none;">
            <h2 class="text-3xl font-bold text-center text-cyan-400 mb-6">Kết Quả Chi Tiết</h2>
            <div class="overflow-x-auto">
                <table class="w-full text-sm text-left text-gray-300">
                    <thead class="text-xs text-cyan-300 uppercase bg-gray-700">
                        <tr>
                            <th class="px-4 py-3">Thuật toán</th>
                            <th class="px-4 py-3">Tốc độ (MB/s)</th>
                            <th class="px-4 py-3">Thông lượng</th>
                            <th class="px-4 py-3">Thời gian/khối (μs)</th>
                            <th class="px-4 py-3">Thời gian tổng (ms)</th>
                            <th class="px-4 py-3">Ước tính CPU (%)</th>
                            <th class="px-4 py-3">Ước tính RAM (KB)</th>
                        </tr>
                    </thead>
                    <tbody id="results-tbody">
                        <!-- Results will be populated dynamically -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        class CryptoPerformanceAnalyzer {
            constructor() {
                this.results = {};
                this.charts = {};
                this.initializeEventListeners();
                this.updateInputStats();
            }

            initializeEventListeners() {
                const plaintextInput = document.getElementById('plaintext');
                const encryptBtn = document.getElementById('encryptBtn');

                plaintextInput.addEventListener('input', () => this.updateInputStats());
                encryptBtn.addEventListener('click', () => this.performAnalysis());
            }

            updateInputStats() {
                const text = document.getElementById('plaintext').value;
                const charCount = text.length;
                const byteCount = new TextEncoder().encode(text).length;
                document.getElementById('inputStats').textContent = 
                    `Độ dài: ${charCount} ký tự, ${byteCount} bytes`;
            }

            async performAnalysis() {
                const text = document.getElementById('plaintext').value;
                if (!text) {
                    alert('Vui lòng nhập dữ liệu để phân tích.');
                    return;
                }

                const btn = document.getElementById('encryptBtn');
                btn.disabled = true;
                btn.textContent = 'Đang phân tích...';
                btn.classList.add('processing');

                try {
                    // Clear previous results
                    this.results = {};
                    
                    // Perform encryption tests
                    await this.testAES(text);
                    await this.testDES(text);
                    await this.test3DES(text);
                    await this.testRC4(text);

                    // Update UI
                    this.displayResults();
                    this.createCharts();
                    this.showPerformanceSection();

                } catch (error) {
                    console.error('Analysis error:', error);
                    alert('Có lỗi xảy ra trong quá trình phân tích.');
                } finally {
                    btn.disabled = false;
                    btn.textContent = 'Thực Hiện Mã Hóa';
                    btn.classList.remove('processing');
                }
            }

            measurePerformance(algorithm, encryptFunction, text) {
                const iterations = 100; // Multiple iterations for accuracy
                const dataSize = new TextEncoder().encode(text).length;
                
                // Warm-up
                for (let i = 0; i < 10; i++) {
                    encryptFunction();
                }

                // Actual measurement
                const startTime = performance.now();
                const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;

                for (let i = 0; i < iterations; i++) {
                    encryptFunction();
                }

                const endTime = performance.now();
                const endMemory = performance.memory ? performance.memory.usedJSHeapSize : startMemory;

                const totalTime = endTime - startTime;
                const averageTime = totalTime / iterations;
                const speed = (dataSize * iterations) / (totalTime / 1000) / (1024 * 1024); // MB/s
                const throughput = speed * 8; // Mbps
                const memoryUsage = Math.abs(endMemory - startMemory) / 1024; // KB
                
                // Estimate CPU usage (simplified)
                const cpuUsage = Math.min(100, (totalTime / (iterations * 10)) * 100);
                
                // Calculate block processing time
                const blockSize = algorithm === 'RC4' ? 1 : (algorithm === 'AES' ? 16 : 8);
                const blocks = Math.ceil(dataSize / blockSize);
                const timePerBlock = blocks > 0 ? (averageTime * 1000) / blocks : 0; // μs per block

                return {
                    algorithm,
                    speed: speed.toFixed(2),
                    throughput: throughput.toFixed(2),
                    averageTime: averageTime.toFixed(3),
                    totalTime: totalTime.toFixed(3),
                    timePerBlock: timePerBlock.toFixed(2),
                    cpuUsage: cpuUsage.toFixed(1),
                    memoryUsage: memoryUsage.toFixed(1),
                    dataSize
                };
            }

            async testAES(text) {
                const key = CryptoJS.lib.WordArray.random(32); // 256-bit key
                const iv = CryptoJS.lib.WordArray.random(16); // 128-bit IV
                
                let encrypted;
                const encryptFunction = () => {
                    encrypted = CryptoJS.AES.encrypt(text, key, { 
                        iv: iv,
                        mode: CryptoJS.mode.CBC,
                        padding: CryptoJS.pad.Pkcs7
                    });
                };

                this.results.aes = this.measurePerformance('AES-256', encryptFunction, text);
                
                // Display result
                document.getElementById('aes-result').innerHTML = `
                    <div class="text-green-400 mb-2">✓ Mã hóa thành công</div>
                    <div class="text-xs text-gray-400">Cipher: ${encrypted.toString().substring(0, 100)}...</div>
                `;
            }

            async testDES(text) {
                const key = CryptoJS.lib.WordArray.random(8); // 64-bit key (56 effective)
                
                let encrypted;
                const encryptFunction = () => {
                    encrypted = CryptoJS.DES.encrypt(text, key, {
                        mode: CryptoJS.mode.ECB,
                        padding: CryptoJS.pad.Pkcs7
                    });
                };

                this.results.des = this.measurePerformance('DES', encryptFunction, text);
                
                document.getElementById('des-result').innerHTML = `
                    <div class="text-green-400 mb-2">✓ Mã hóa thành công</div>
                    <div class="text-xs text-gray-400">Cipher: ${encrypted.toString().substring(0, 100)}...</div>
                `;
            }

            async test3DES(text) {
                const key = CryptoJS.lib.WordArray.random(24); // 192-bit key (168 effective)
                
                let encrypted;
                const encryptFunction = () => {
                    encrypted = CryptoJS.TripleDES.encrypt(text, key, {
                        mode: CryptoJS.mode.ECB,
                        padding: CryptoJS.pad.Pkcs7
                    });
                };

                this.results.tripledes = this.measurePerformance('3DES', encryptFunction, text);
                
                document.getElementById('tripledes-result').innerHTML = `
                    <div class="text-green-400 mb-2">✓ Mã hóa thành công</div>
                    <div class="text-xs text-gray-400">Cipher: ${encrypted.toString().substring(0, 100)}...</div>
                `;
            }

            async testRC4(text) {
                const key = CryptoJS.lib.WordArray.random(16); // 128-bit key
                
                let encrypted;
                const encryptFunction = () => {
                    encrypted = CryptoJS.RC4.encrypt(text, key);
                };

                this.results.rc4 = this.measurePerformance('RC4', encryptFunction, text);
                
                document.getElementById('rc4-result').innerHTML = `
                    <div class="text-green-400 mb-2">✓ Mã hóa thành công</div>
                    <div class="text-xs text-gray-400">Cipher: ${encrypted.toString().substring(0, 100)}...</div>
                `;
            }

            displayResults() {
                // Update metrics grid
                const metricsGrid = document.getElementById('metrics-grid');
                metricsGrid.innerHTML = '';

                const metrics = [
                    { label: 'Tốc Độ TB', unit: 'MB/s', getValue: (r) => r.speed },
                    { label: 'Thông Lượng TB', unit: 'Mbps', getValue: (r) => r.throughput },
                    { label: 'Thời Gian TB', unit: 'ms', getValue: (r) => r.averageTime },
                    { label: 'CPU TB', unit: '%', getValue: (r) => r.cpuUsage },
                    { label: 'RAM TB', unit: 'KB', getValue: (r) => r.memoryUsage },
                    { label: 'Thời Gian/Khối', unit: 'μs', getValue: (r) => r.timePerBlock }
                ];

                metrics.forEach(metric => {
                    const values = Object.values(this.results).map(r => parseFloat(metric.getValue(r)));
                    const average = (values.reduce((a, b) => a + b, 0) / values.length).toFixed(2);
                    
                    const metricDiv = document.createElement('div');
                    metricDiv.className = 'performance-metric p-4 rounded-lg text-center';
                    metricDiv.innerHTML = `
                        <div class="text-2xl font-bold text-cyan-400">${average}</div>
                        <div class="text-xs text-gray-400">${metric.label}</div>
                        <div class="text-xs text-gray-500">${metric.unit}</div>
                    `;
                    metricsGrid.appendChild(metricDiv);
                });

                // Update results table
                const tbody = document.getElementById('results-tbody');
                tbody.innerHTML = '';

                Object.values(this.results).forEach(result => {
                    const row = document.createElement('tr');
                    row.className = 'bg-gray-800 border-b border-gray-700';
                    row.innerHTML = `
                        <td class="px-4 py-3 font-bold text-lg">${result.algorithm}</td>
                        <td class="px-4 py-3 font-mono">${result.speed}</td>
                        <td class="px-4 py-3 font-mono">${result.throughput} Mbps</td>
                        <td class="px-4 py-3 font-mono">${result.timePerBlock}</td>
                        <td class="px-4 py-3 font-mono">${result.averageTime}</td>
                        <td class="px-4 py-3 font-mono">${result.cpuUsage}</td>
                        <td class="px-4 py-3 font-mono">${result.memoryUsage}</td>
                    `;
                    tbody.appendChild(row);
                });
            }

            createCharts() {
                // Destroy existing charts
                Object.values(this.charts).forEach(chart => chart.destroy());
                this.charts = {};

                const algorithms = Object.keys(this.results);
                const colors = {
                    'AES-256': '#22c55e',
                    'DES': '#ef4444', 
                    '3DES': '#3b82f6',
                    'RC4': '#8b5cf6'
                };

                // Speed Chart
                const speedCtx = document.getElementById('speedChart').getContext('2d');
                this.charts.speed = new Chart(speedCtx, {
                    type: 'bar',
                    data: {
                        labels: algorithms,
                        datasets: [{
                            label: 'Tốc độ (MB/s)',
                            data: algorithms.map(algo => parseFloat(this.results[algo].speed)),
                            backgroundColor: algorithms.map(algo => colors[this.results[algo].algorithm]),
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { 
                                beginAtZero: true,
                                ticks: { color: '#d1d5db' }
                            },
                            x: { ticks: { color: '#d1d5db' } }
                        }
                    }
                });

                // Time Chart
                const timeCtx = document.getElementById('timeChart').getContext('2d');
                this.charts.time = new Chart(timeCtx, {
                    type: 'bar',
                    data: {
                        labels: algorithms,
                        datasets: [{
                            label: 'Thời gian (ms)',
                            data: algorithms.map(algo => parseFloat(this.results[algo].averageTime)),
                            backgroundColor: algorithms.map(algo => colors[this.results[algo].algorithm]),
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { 
                                beginAtZero: true,
                                ticks: { color: '#d1d5db' }
                            },
                            x: { ticks: { color: '#d1d5db' } }
                        }
                    }
                });

                // Throughput Chart (Line)
                const throughputCtx = document.getElementById('throughputChart').getContext('2d');
                this.charts.throughput = new Chart(throughputCtx, {
                    type: 'line',
                    data: {
                        labels: algorithms,
                        datasets: [{
                            label: 'Thông lượng (Mbps)',
                            data: algorithms.map(algo => parseFloat(this.results[algo].throughput)),
                            borderColor: '#06b6d4',
                            backgroundColor: 'rgba(6, 182, 212, 0.1)',
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { labels: { color: '#d1d5db' } } },
                        scales: {
                            y: { 
                                beginAtZero: true,
                                ticks: { color: '#d1d5db' }
                            },
                            x: { ticks: { color: '#d1d5db' } }
                        }
                    }
                });

                // Resource Usage Chart (Radar)
                const resourceCtx = document.getElementById('resourceChart').getContext('2d');
                this.charts.resource = new Chart(resourceCtx, {
                    type: 'radar',
                    data: {
                        labels: ['Hiệu quả CPU (ít % tốt)', 'Hiệu quả Memory (ít KB tốt)', 'Tốc độ (MB/s)', 'Hiệu suất thời gian'],
                        datasets: algorithms.map(algo => {
                            const result = this.results[algo];
                            
                            // For CPU and Memory: Lower is better (invert the values)
                            // Convert to "efficiency" where higher values mean better performance
                            const cpuEfficiency = Math.max(0, 100 - parseFloat(result.cpuUsage));
                            const memoryEfficiency = Math.max(0, 100 - Math.min(100, parseFloat(result.memoryUsage)));
                            
                            // For Speed and Time Efficiency: Higher is better (keep as is)
                            const speedScore = Math.min(100, parseFloat(result.speed) * 10);
                            const timeEfficiency = Math.min(100, (1 / parseFloat(result.averageTime)) * 10);
                            
                            return {
                                label: result.algorithm,
                                data: [
                                    cpuEfficiency,
                                    memoryEfficiency, 
                                    speedScore,
                                    timeEfficiency
                                ],
                                borderColor: colors[result.algorithm],
                                backgroundColor: colors[result.algorithm] + '20',
                                fill: true,
                                borderWidth: 2
                            };
                        })
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { 
                                labels: { color: '#d1d5db' }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) { label += ': '; }
                                        label += context.parsed.r.toFixed(1) + '/100';
                                        
                                        // Add explanation based on metric
                                        const explanations = [
                                            ' (CPU thấp = tốt)',
                                            ' (RAM thấp = tốt)', 
                                            ' (Tốc độ cao = tốt)',
                                            ' (Thời gian ngắn = tốt)'
                                        ];
                                        label += explanations[context.dataIndex];
                                        
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            r: {
                                angleLines: { color: '#4b5563' },
                                grid: { color: '#4b5563' },
                                pointLabels: { 
                                    color: '#d1d5db',
                                    font: { size: 9 }
                                },
                                ticks: { 
                                    display: false,
                                    max: 100,
                                    min: 0
                                }
                            }
                        }
                    }
                });
            }

            showPerformanceSection() {
                document.getElementById('performance-section').style.display = 'block';
                document.getElementById('results-table').style.display = 'block';
            }

            // Simplified implementations for demonstration
            simpleRC4(text, key) {
                // Simplified RC4 implementation for demo
                const keyArray = key.toString().split('').map(c => c.charCodeAt(0));
                const S = Array.from({length: 256}, (_, i) => i);
                
                // KSA (Key Scheduling Algorithm)
                let j = 0;
                for (let i = 0; i < 256; i++) {
                    j = (j + S[i] + keyArray[i % keyArray.length]) % 256;
                    [S[i], S[j]] = [S[j], S[i]];
                }
                
                // PRGA (Pseudo-Random Generation Algorithm)
                let i = 0;
                j = 0;
                const result = [];
                for (let k = 0; k < text.length; k++) {
                    i = (i + 1) % 256;
                    j = (j + S[i]) % 256;
                    [S[i], S[j]] = [S[j], S[i]];
                    const keyStream = S[(S[i] + S[j]) % 256];
                    result.push(text.charCodeAt(k) ^ keyStream);
                }
                
                return result.map(c => c.toString(16).padStart(2, '0')).join('');
            }
        }

        // Initialize the analyzer when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new CryptoPerformanceAnalyzer();
        });
    </script>

</body>
</html>
